// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Libretro
{
    public enum RetroLanguage
    {
        RETRO_LANGUAGE_ENGLISH = 0,
        RETRO_LANGUAGE_JAPANESE = 1,
        RETRO_LANGUAGE_FRENCH = 2,
        RETRO_LANGUAGE_SPANISH = 3,
        RETRO_LANGUAGE_GERMAN = 4,
        RETRO_LANGUAGE_ITALIAN = 5,
        RETRO_LANGUAGE_DUTCH = 6,
        RETRO_LANGUAGE_PORTUGUESE_BRAZIL = 7,
        RETRO_LANGUAGE_PORTUGUESE_PORTUGAL = 8,
        RETRO_LANGUAGE_RUSSIAN = 9,
        RETRO_LANGUAGE_KOREAN = 10,
        RETRO_LANGUAGE_CHINESE_TRADITIONAL = 11,
        RETRO_LANGUAGE_CHINESE_SIMPLIFIED = 12,
        RETRO_LANGUAGE_ESPERANTO = 13,
        RETRO_LANGUAGE_POLISH = 14,
        RETRO_LANGUAGE_VIETNAMESE = 15,
        RETRO_LANGUAGE_ARABIC = 16,
        RETRO_LANGUAGE_GREEK = 17,
        RETRO_LANGUAGE_TURKISH = 18,
        RETRO_LANGUAGE_SLOVAK = 19,
        RETRO_LANGUAGE_PERSIAN = 20,
        RETRO_LANGUAGE_HEBREW = 21,
        RETRO_LANGUAGE_ASTURIAN = 22,
        RETRO_LANGUAGE_FINNISH = 23,
        RETRO_LANGUAGE_LAST = 24,
        RETRO_LANGUAGE_DUMMY = 2147483647
    }

    public enum RetroKey
    {
        RETROK_UNKNOWN = 0,
        RETROK_FIRST = 0,
        RETROK_BACKSPACE = 8,
        RETROK_TAB = 9,
        RETROK_CLEAR = 12,
        RETROK_RETURN = 13,
        RETROK_PAUSE = 19,
        RETROK_ESCAPE = 27,
        RETROK_SPACE = 32,
        RETROK_EXCLAIM = 33,
        RETROK_QUOTEDBL = 34,
        RETROK_HASH = 35,
        RETROK_DOLLAR = 36,
        RETROK_AMPERSAND = 38,
        RETROK_QUOTE = 39,
        RETROK_LEFTPAREN = 40,
        RETROK_RIGHTPAREN = 41,
        RETROK_ASTERISK = 42,
        RETROK_PLUS = 43,
        RETROK_COMMA = 44,
        RETROK_MINUS = 45,
        RETROK_PERIOD = 46,
        RETROK_SLASH = 47,
        RETROK_0 = 48,
        RETROK_1 = 49,
        RETROK_2 = 50,
        RETROK_3 = 51,
        RETROK_4 = 52,
        RETROK_5 = 53,
        RETROK_6 = 54,
        RETROK_7 = 55,
        RETROK_8 = 56,
        RETROK_9 = 57,
        RETROK_COLON = 58,
        RETROK_SEMICOLON = 59,
        RETROK_LESS = 60,
        RETROK_EQUALS = 61,
        RETROK_GREATER = 62,
        RETROK_QUESTION = 63,
        RETROK_AT = 64,
        RETROK_LEFTBRACKET = 91,
        RETROK_BACKSLASH = 92,
        RETROK_RIGHTBRACKET = 93,
        RETROK_CARET = 94,
        RETROK_UNDERSCORE = 95,
        RETROK_BACKQUOTE = 96,
        RETROK_a = 97,
        RETROK_b = 98,
        RETROK_c = 99,
        RETROK_d = 100,
        RETROK_e = 101,
        RETROK_f = 102,
        RETROK_g = 103,
        RETROK_h = 104,
        RETROK_i = 105,
        RETROK_j = 106,
        RETROK_k = 107,
        RETROK_l = 108,
        RETROK_m = 109,
        RETROK_n = 110,
        RETROK_o = 111,
        RETROK_p = 112,
        RETROK_q = 113,
        RETROK_r = 114,
        RETROK_s = 115,
        RETROK_t = 116,
        RETROK_u = 117,
        RETROK_v = 118,
        RETROK_w = 119,
        RETROK_x = 120,
        RETROK_y = 121,
        RETROK_z = 122,
        RETROK_LEFTBRACE = 123,
        RETROK_BAR = 124,
        RETROK_RIGHTBRACE = 125,
        RETROK_TILDE = 126,
        RETROK_DELETE = 127,
        RETROK_KP0 = 256,
        RETROK_KP1 = 257,
        RETROK_KP2 = 258,
        RETROK_KP3 = 259,
        RETROK_KP4 = 260,
        RETROK_KP5 = 261,
        RETROK_KP6 = 262,
        RETROK_KP7 = 263,
        RETROK_KP8 = 264,
        RETROK_KP9 = 265,
        RETROK_KP_PERIOD = 266,
        RETROK_KP_DIVIDE = 267,
        RETROK_KP_MULTIPLY = 268,
        RETROK_KP_MINUS = 269,
        RETROK_KP_PLUS = 270,
        RETROK_KP_ENTER = 271,
        RETROK_KP_EQUALS = 272,
        RETROK_UP = 273,
        RETROK_DOWN = 274,
        RETROK_RIGHT = 275,
        RETROK_LEFT = 276,
        RETROK_INSERT = 277,
        RETROK_HOME = 278,
        RETROK_END = 279,
        RETROK_PAGEUP = 280,
        RETROK_PAGEDOWN = 281,
        RETROK_F1 = 282,
        RETROK_F2 = 283,
        RETROK_F3 = 284,
        RETROK_F4 = 285,
        RETROK_F5 = 286,
        RETROK_F6 = 287,
        RETROK_F7 = 288,
        RETROK_F8 = 289,
        RETROK_F9 = 290,
        RETROK_F10 = 291,
        RETROK_F11 = 292,
        RETROK_F12 = 293,
        RETROK_F13 = 294,
        RETROK_F14 = 295,
        RETROK_F15 = 296,
        RETROK_NUMLOCK = 300,
        RETROK_CAPSLOCK = 301,
        RETROK_SCROLLOCK = 302,
        RETROK_RSHIFT = 303,
        RETROK_LSHIFT = 304,
        RETROK_RCTRL = 305,
        RETROK_LCTRL = 306,
        RETROK_RALT = 307,
        RETROK_LALT = 308,
        RETROK_RMETA = 309,
        RETROK_LMETA = 310,
        RETROK_LSUPER = 311,
        RETROK_RSUPER = 312,
        RETROK_MODE = 313,
        RETROK_COMPOSE = 314,
        RETROK_HELP = 315,
        RETROK_PRINT = 316,
        RETROK_SYSREQ = 317,
        RETROK_BREAK = 318,
        RETROK_MENU = 319,
        RETROK_POWER = 320,
        RETROK_EURO = 321,
        RETROK_UNDO = 322,
        RETROK_OEM_102 = 323,
        RETROK_LAST = 324,
        RETROK_DUMMY = 2147483647
    }

    public enum RetroMod
    {
        RETROKMOD_NONE = 0,
        RETROKMOD_SHIFT = 1,
        RETROKMOD_CTRL = 2,
        RETROKMOD_ALT = 4,
        RETROKMOD_META = 8,
        RETROKMOD_NUMLOCK = 16,
        RETROKMOD_CAPSLOCK = 32,
        RETROKMOD_SCROLLOCK = 64,
        RETROKMOD_DUMMY = 2147483647
    }

    public enum RetroHwRenderInterfaceType
    {
        RETRO_HW_RENDER_INTERFACE_VULKAN = 0,
        RETRO_HW_RENDER_INTERFACE_D3D9 = 1,
        RETRO_HW_RENDER_INTERFACE_D3D10 = 2,
        RETRO_HW_RENDER_INTERFACE_D3D11 = 3,
        RETRO_HW_RENDER_INTERFACE_D3D12 = 4,
        RETRO_HW_RENDER_INTERFACE_GSKIT_PS2 = 5,
        RETRO_HW_RENDER_INTERFACE_DUMMY = 2147483647
    }

    public enum RetroHwRenderContextNegotiationInterfaceType
    {
        RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN = 0,
        RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_DUMMY = 2147483647
    }

    public enum RetroLogLevel
    {
        RETRO_LOG_DEBUG = 0,
        RETRO_LOG_INFO = 1,
        RETRO_LOG_WARN = 2,
        RETRO_LOG_ERROR = 3,
        RETRO_LOG_DUMMY = 2147483647
    }

    public enum RetroSensorAction
    {
        RETRO_SENSOR_ACCELEROMETER_ENABLE = 0,
        RETRO_SENSOR_ACCELEROMETER_DISABLE = 1,
        RETRO_SENSOR_GYROSCOPE_ENABLE = 2,
        RETRO_SENSOR_GYROSCOPE_DISABLE = 3,
        RETRO_SENSOR_ILLUMINANCE_ENABLE = 4,
        RETRO_SENSOR_ILLUMINANCE_DISABLE = 5,
        RETRO_SENSOR_DUMMY = 2147483647
    }

    public enum RetroCameraBuffer
    {
        RETRO_CAMERA_BUFFER_OPENGL_TEXTURE = 0,
        RETRO_CAMERA_BUFFER_RAW_FRAMEBUFFER = 1,
        RETRO_CAMERA_BUFFER_DUMMY = 2147483647
    }

    public enum RetroRumbleEffect
    {
        RETRO_RUMBLE_STRONG = 0,
        RETRO_RUMBLE_WEAK = 1,
        RETRO_RUMBLE_DUMMY = 2147483647
    }

    public enum RetroHwContextType
    {
        RETRO_HW_CONTEXT_NONE = 0,
        RETRO_HW_CONTEXT_OPENGL = 1,
        RETRO_HW_CONTEXT_OPENGLES2 = 2,
        RETRO_HW_CONTEXT_OPENGL_CORE = 3,
        RETRO_HW_CONTEXT_OPENGLES3 = 4,
        RETRO_HW_CONTEXT_OPENGLES_VERSION = 5,
        RETRO_HW_CONTEXT_VULKAN = 6,
        RETRO_HW_CONTEXT_DIRECT3D = 7,
        RETRO_HW_CONTEXT_DUMMY = 2147483647
    }

    public enum RetroPixelFormat
    {
        RETRO_PIXEL_FORMAT_0RGB1555 = 0,
        RETRO_PIXEL_FORMAT_XRGB8888 = 1,
        RETRO_PIXEL_FORMAT_RGB565 = 2,
        RETRO_PIXEL_FORMAT_UNKNOWN = 2147483647
    }

    public enum RetroMessageTarget
    {
        RETRO_MESSAGE_TARGET_ALL = 0,
        RETRO_MESSAGE_TARGET_OSD = 1,
        RETRO_MESSAGE_TARGET_LOG = 2
    }

    public enum RetroMessageType
    {
        RETRO_MESSAGE_TYPE_NOTIFICATION = 0,
        RETRO_MESSAGE_TYPE_NOTIFICATION_ALT = 1,
        RETRO_MESSAGE_TYPE_STATUS = 2,
        RETRO_MESSAGE_TYPE_PROGRESS = 3
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr RetroVfsGetPathT(__IntPtr stream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr RetroVfsOpenT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, uint mode, uint hints);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int RetroVfsCloseT(__IntPtr stream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long RetroVfsSizeT(__IntPtr stream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long RetroVfsTruncateT(__IntPtr stream, long length);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long RetroVfsTellT(__IntPtr stream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long RetroVfsSeekT(__IntPtr stream, long offset, int seek_position);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long RetroVfsReadT(__IntPtr stream, __IntPtr s, ulong len);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long RetroVfsWriteT(__IntPtr stream, __IntPtr s, ulong len);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int RetroVfsFlushT(__IntPtr stream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int RetroVfsRemoveT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int RetroVfsRenameT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string old_path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string new_path);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int RetroVfsStatT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, int* size);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int RetroVfsMkdirT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dir);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr RetroVfsOpendirT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dir, [MarshalAs(UnmanagedType.I1)] bool include_hidden);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroVfsReaddirT(__IntPtr dirstream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr RetroVfsDirentGetNameT(__IntPtr dirstream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroVfsDirentIsDirT(__IntPtr dirstream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int RetroVfsClosedirT(__IntPtr dirstream);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroSetLedStateT(int led, int state);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroMidiInputEnabledT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroMidiOutputEnabledT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroMidiReadT(byte* @byte);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroMidiWriteT(byte @byte, uint delta_time);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroMidiFlushT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroProcAddressT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Libretro.RetroProcAddressT RetroGetProcAddressT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sym);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroLogPrintfT(global::Libretro.RetroLogLevel level, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long RetroPerfGetTimeUsecT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate ulong RetroPerfGetCounterT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate ulong RetroGetCpuFeaturesT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroPerfLogT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroPerfRegisterT(__IntPtr counter);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroPerfStartT(__IntPtr counter);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroPerfStopT(__IntPtr counter);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroSetSensorStateT(uint port, global::Libretro.RetroSensorAction action, uint rate);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate float RetroSensorGetInputT(uint port, uint id);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroCameraStartT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroCameraStopT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroCameraLifetimeStatusT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroCameraFrameRawFramebufferT(uint* buffer, uint width, uint height, ulong pitch);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroCameraFrameOpenglTextureT(uint texture_id, uint texture_target, float* affine);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroLocationSetIntervalT(uint interval_ms, uint interval_distance);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroLocationStartT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroLocationStopT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroLocationGetPositionT(double* lat, double* lon, double* horiz_accuracy, double* vert_accuracy);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroLocationLifetimeStatusT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroSetRumbleStateT(uint port, global::Libretro.RetroRumbleEffect effect, ushort strength);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroAudioCallbackT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroAudioSetStateCallbackT([MarshalAs(UnmanagedType.I1)] bool enabled);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroFrameTimeCallbackT(long usec);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroAudioBufferStatusCallbackT([MarshalAs(UnmanagedType.I1)] bool active, uint occupancy, [MarshalAs(UnmanagedType.I1)] bool underrun_likely);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroHwContextResetT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate ulong RetroHwGetCurrentFramebufferT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Libretro.RetroProcAddressT RetroHwGetProcAddressT([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string sym);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroKeyboardEventT([MarshalAs(UnmanagedType.I1)] bool down, uint keycode, uint character, ushort key_modifiers);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroSetEjectStateT([MarshalAs(UnmanagedType.I1)] bool ejected);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroGetEjectStateT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate uint RetroGetImageIndexT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroSetImageIndexT(uint index);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate uint RetroGetNumImagesT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroReplaceImageIndexT(uint index, __IntPtr info);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroAddImageIndexT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroSetInitialImageT(uint index, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroGetImagePathT(uint index, sbyte* path, ulong len);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroGetImageLabelT(uint index, sbyte* label, ulong len);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroCoreOptionsUpdateDisplayCallbackT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    [return: MarshalAs(UnmanagedType.I1)]
    public unsafe delegate bool RetroEnvironmentT(uint cmd, __IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroVideoRefreshT(__IntPtr data, uint width, uint height, ulong pitch);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroAudioSampleT(short left, short right);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate ulong RetroAudioSampleBatchT(short* data, ulong frames);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void RetroInputPollT();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate short RetroInputStateT(uint port, uint device, uint index, uint id);

    public unsafe partial class RetroVfsFileHandle
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsFileHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsFileHandle>();

        protected bool __ownsNativeInstance;

        internal static RetroVfsFileHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroVfsFileHandle(native.ToPointer(), skipVTables);
        }

        internal static RetroVfsFileHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroVfsFileHandle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroVfsFileHandle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroVfsFileHandle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroVfsFileHandle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroVfsFileHandle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class RetroVfsDirHandle
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsDirHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsDirHandle>();

        protected bool __ownsNativeInstance;

        internal static RetroVfsDirHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroVfsDirHandle(native.ToPointer(), skipVTables);
        }

        internal static RetroVfsDirHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroVfsDirHandle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroVfsDirHandle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroVfsDirHandle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroVfsDirHandle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroVfsDirHandle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class RetroVfsInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 152)]
        public partial struct __Internal
        {
            internal __IntPtr get_path;
            internal __IntPtr open;
            internal __IntPtr close;
            internal __IntPtr size;
            internal __IntPtr tell;
            internal __IntPtr seek;
            internal __IntPtr read;
            internal __IntPtr write;
            internal __IntPtr flush;
            internal __IntPtr remove;
            internal __IntPtr rename;
            internal __IntPtr truncate;
            internal __IntPtr stat;
            internal __IntPtr mkdir;
            internal __IntPtr opendir;
            internal __IntPtr readdir;
            internal __IntPtr dirent_get_name;
            internal __IntPtr dirent_is_dir;
            internal __IntPtr closedir;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_vfs_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroVfsInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroVfsInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroVfsInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroVfsInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroVfsInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroVfsInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroVfsInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroVfsInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroVfsInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroVfsInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroVfsInterface(global::Libretro.RetroVfsInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroVfsInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroVfsInterface.__Internal*) __Instance) = *((global::Libretro.RetroVfsInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroVfsGetPathT GetPath
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_path;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsGetPathT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsGetPathT));
            }

            set
            {
                ((__Internal*)__Instance)->get_path = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsOpenT Open
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->open;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsOpenT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsOpenT));
            }

            set
            {
                ((__Internal*)__Instance)->open = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsCloseT Close
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->close;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsCloseT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsCloseT));
            }

            set
            {
                ((__Internal*)__Instance)->close = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsSizeT Size
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->size;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsSizeT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsSizeT));
            }

            set
            {
                ((__Internal*)__Instance)->size = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsTellT Tell
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->tell;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsTellT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsTellT));
            }

            set
            {
                ((__Internal*)__Instance)->tell = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsSeekT Seek
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->seek;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsSeekT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsSeekT));
            }

            set
            {
                ((__Internal*)__Instance)->seek = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsReadT Read
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsReadT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsReadT));
            }

            set
            {
                ((__Internal*)__Instance)->read = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsWriteT Write
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsWriteT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsWriteT));
            }

            set
            {
                ((__Internal*)__Instance)->write = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsFlushT Flush
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->flush;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsFlushT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsFlushT));
            }

            set
            {
                ((__Internal*)__Instance)->flush = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsRemoveT Remove
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->remove;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsRemoveT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsRemoveT));
            }

            set
            {
                ((__Internal*)__Instance)->remove = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsRenameT Rename
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->rename;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsRenameT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsRenameT));
            }

            set
            {
                ((__Internal*)__Instance)->rename = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsTruncateT Truncate
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->truncate;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsTruncateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsTruncateT));
            }

            set
            {
                ((__Internal*)__Instance)->truncate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsStatT Stat
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->stat;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsStatT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsStatT));
            }

            set
            {
                ((__Internal*)__Instance)->stat = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsMkdirT Mkdir
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->mkdir;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsMkdirT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsMkdirT));
            }

            set
            {
                ((__Internal*)__Instance)->mkdir = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsOpendirT Opendir
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->opendir;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsOpendirT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsOpendirT));
            }

            set
            {
                ((__Internal*)__Instance)->opendir = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsReaddirT Readdir
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->readdir;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsReaddirT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsReaddirT));
            }

            set
            {
                ((__Internal*)__Instance)->readdir = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsDirentGetNameT DirentGetName
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dirent_get_name;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsDirentGetNameT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsDirentGetNameT));
            }

            set
            {
                ((__Internal*)__Instance)->dirent_get_name = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsDirentIsDirT DirentIsDir
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->dirent_is_dir;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsDirentIsDirT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsDirentIsDirT));
            }

            set
            {
                ((__Internal*)__Instance)->dirent_is_dir = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroVfsClosedirT Closedir
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->closedir;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroVfsClosedirT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroVfsClosedirT));
            }

            set
            {
                ((__Internal*)__Instance)->closedir = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroVfsInterfaceInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint required_interface_version;
            internal __IntPtr iface;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_vfs_interface_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsInterfaceInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVfsInterfaceInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroVfsInterfaceInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroVfsInterfaceInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroVfsInterfaceInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroVfsInterfaceInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroVfsInterfaceInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroVfsInterfaceInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroVfsInterfaceInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroVfsInterfaceInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroVfsInterfaceInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroVfsInterfaceInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroVfsInterfaceInfo(global::Libretro.RetroVfsInterfaceInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroVfsInterfaceInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroVfsInterfaceInfo.__Internal*) __Instance) = *((global::Libretro.RetroVfsInterfaceInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint RequiredInterfaceVersion
        {
            get
            {
                return ((__Internal*)__Instance)->required_interface_version;
            }

            set
            {
                ((__Internal*)__Instance)->required_interface_version = value;
            }
        }

        public global::Libretro.RetroVfsInterface Iface
        {
            get
            {
                var __result0 = global::Libretro.RetroVfsInterface.__GetOrCreateInstance(((__Internal*)__Instance)->iface, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->iface = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class RetroHwRenderInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::Libretro.RetroHwRenderInterfaceType interface_type;
            internal uint interface_version;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_hw_render_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroHwRenderInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroHwRenderInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroHwRenderInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroHwRenderInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroHwRenderInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroHwRenderInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroHwRenderInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroHwRenderInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroHwRenderInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroHwRenderInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroHwRenderInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroHwRenderInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroHwRenderInterface(global::Libretro.RetroHwRenderInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroHwRenderInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroHwRenderInterface.__Internal*) __Instance) = *((global::Libretro.RetroHwRenderInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroHwRenderInterfaceType InterfaceType
        {
            get
            {
                return ((__Internal*)__Instance)->interface_type;
            }

            set
            {
                ((__Internal*)__Instance)->interface_type = value;
            }
        }

        public uint InterfaceVersion
        {
            get
            {
                return ((__Internal*)__Instance)->interface_version;
            }

            set
            {
                ((__Internal*)__Instance)->interface_version = value;
            }
        }
    }

    public unsafe partial class RetroLedInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr set_led_state;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_led_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroLedInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroLedInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroLedInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroLedInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroLedInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroLedInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroLedInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroLedInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroLedInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroLedInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroLedInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroLedInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroLedInterface(global::Libretro.RetroLedInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroLedInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroLedInterface.__Internal*) __Instance) = *((global::Libretro.RetroLedInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroSetLedStateT SetLedState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_led_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetLedStateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetLedStateT));
            }

            set
            {
                ((__Internal*)__Instance)->set_led_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroMidiInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr input_enabled;
            internal __IntPtr output_enabled;
            internal __IntPtr read;
            internal __IntPtr write;
            internal __IntPtr flush;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_midi_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMidiInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMidiInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroMidiInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroMidiInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroMidiInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroMidiInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroMidiInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroMidiInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroMidiInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroMidiInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroMidiInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMidiInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroMidiInterface(global::Libretro.RetroMidiInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMidiInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroMidiInterface.__Internal*) __Instance) = *((global::Libretro.RetroMidiInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroMidiInputEnabledT InputEnabled
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->input_enabled;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroMidiInputEnabledT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroMidiInputEnabledT));
            }

            set
            {
                ((__Internal*)__Instance)->input_enabled = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroMidiOutputEnabledT OutputEnabled
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->output_enabled;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroMidiOutputEnabledT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroMidiOutputEnabledT));
            }

            set
            {
                ((__Internal*)__Instance)->output_enabled = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroMidiReadT Read
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroMidiReadT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroMidiReadT));
            }

            set
            {
                ((__Internal*)__Instance)->read = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroMidiWriteT Write
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroMidiWriteT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroMidiWriteT));
            }

            set
            {
                ((__Internal*)__Instance)->write = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroMidiFlushT Flush
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->flush;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroMidiFlushT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroMidiFlushT));
            }

            set
            {
                ((__Internal*)__Instance)->flush = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroHwRenderContextNegotiationInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::Libretro.RetroHwRenderContextNegotiationInterfaceType interface_type;
            internal uint interface_version;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_hw_render_context_negotiation_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroHwRenderContextNegotiationInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroHwRenderContextNegotiationInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroHwRenderContextNegotiationInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroHwRenderContextNegotiationInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroHwRenderContextNegotiationInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroHwRenderContextNegotiationInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroHwRenderContextNegotiationInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroHwRenderContextNegotiationInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroHwRenderContextNegotiationInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroHwRenderContextNegotiationInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroHwRenderContextNegotiationInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroHwRenderContextNegotiationInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroHwRenderContextNegotiationInterface(global::Libretro.RetroHwRenderContextNegotiationInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroHwRenderContextNegotiationInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroHwRenderContextNegotiationInterface.__Internal*) __Instance) = *((global::Libretro.RetroHwRenderContextNegotiationInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroHwRenderContextNegotiationInterfaceType InterfaceType
        {
            get
            {
                return ((__Internal*)__Instance)->interface_type;
            }

            set
            {
                ((__Internal*)__Instance)->interface_type = value;
            }
        }

        public uint InterfaceVersion
        {
            get
            {
                return ((__Internal*)__Instance)->interface_version;
            }

            set
            {
                ((__Internal*)__Instance)->interface_version = value;
            }
        }
    }

    public unsafe partial class RetroMemoryDescriptor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal ulong flags;
            internal __IntPtr ptr;
            internal ulong offset;
            internal ulong start;
            internal ulong select;
            internal ulong disconnect;
            internal ulong len;
            internal __IntPtr addrspace;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_memory_descriptor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMemoryDescriptor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMemoryDescriptor>();

        protected bool __ownsNativeInstance;

        internal static RetroMemoryDescriptor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroMemoryDescriptor(native.ToPointer(), skipVTables);
        }

        internal static RetroMemoryDescriptor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroMemoryDescriptor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroMemoryDescriptor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroMemoryDescriptor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroMemoryDescriptor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroMemoryDescriptor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroMemoryDescriptor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMemoryDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroMemoryDescriptor(global::Libretro.RetroMemoryDescriptor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMemoryDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroMemoryDescriptor.__Internal*) __Instance) = *((global::Libretro.RetroMemoryDescriptor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        public __IntPtr Ptr
        {
            get
            {
                return ((__Internal*)__Instance)->ptr;
            }

            set
            {
                ((__Internal*)__Instance)->ptr = (__IntPtr) value;
            }
        }

        public ulong Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        public ulong Start
        {
            get
            {
                return ((__Internal*)__Instance)->start;
            }

            set
            {
                ((__Internal*)__Instance)->start = value;
            }
        }

        public ulong Select
        {
            get
            {
                return ((__Internal*)__Instance)->select;
            }

            set
            {
                ((__Internal*)__Instance)->select = value;
            }
        }

        public ulong Disconnect
        {
            get
            {
                return ((__Internal*)__Instance)->disconnect;
            }

            set
            {
                ((__Internal*)__Instance)->disconnect = value;
            }
        }

        public ulong Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }

        public string Addrspace
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->addrspace);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->addrspace = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroMemoryMap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr descriptors;
            internal uint num_descriptors;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_memory_map@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMemoryMap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMemoryMap>();

        protected bool __ownsNativeInstance;

        internal static RetroMemoryMap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroMemoryMap(native.ToPointer(), skipVTables);
        }

        internal static RetroMemoryMap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroMemoryMap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroMemoryMap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroMemoryMap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroMemoryMap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroMemoryMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroMemoryMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMemoryMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroMemoryMap(global::Libretro.RetroMemoryMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMemoryMap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroMemoryMap.__Internal*) __Instance) = *((global::Libretro.RetroMemoryMap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroMemoryDescriptor Descriptors
        {
            get
            {
                var __result0 = global::Libretro.RetroMemoryDescriptor.__GetOrCreateInstance(((__Internal*)__Instance)->descriptors, false);
                return __result0;
            }
        }

        public uint NumDescriptors
        {
            get
            {
                return ((__Internal*)__Instance)->num_descriptors;
            }

            set
            {
                ((__Internal*)__Instance)->num_descriptors = value;
            }
        }
    }

    public unsafe partial class RetroControllerDescription : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr desc;
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_controller_description@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroControllerDescription> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroControllerDescription>();

        protected bool __ownsNativeInstance;

        internal static RetroControllerDescription __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroControllerDescription(native.ToPointer(), skipVTables);
        }

        internal static RetroControllerDescription __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroControllerDescription)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroControllerDescription __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroControllerDescription(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroControllerDescription(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroControllerDescription(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroControllerDescription()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroControllerDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroControllerDescription(global::Libretro.RetroControllerDescription _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroControllerDescription.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroControllerDescription.__Internal*) __Instance) = *((global::Libretro.RetroControllerDescription.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->desc);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->desc = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class RetroControllerInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr types;
            internal uint num_types;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_controller_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroControllerInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroControllerInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroControllerInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroControllerInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroControllerInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroControllerInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroControllerInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroControllerInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroControllerInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroControllerInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroControllerInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroControllerInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroControllerInfo(global::Libretro.RetroControllerInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroControllerInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroControllerInfo.__Internal*) __Instance) = *((global::Libretro.RetroControllerInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroControllerDescription Types
        {
            get
            {
                var __result0 = global::Libretro.RetroControllerDescription.__GetOrCreateInstance(((__Internal*)__Instance)->types, false);
                return __result0;
            }
        }

        public uint NumTypes
        {
            get
            {
                return ((__Internal*)__Instance)->num_types;
            }

            set
            {
                ((__Internal*)__Instance)->num_types = value;
            }
        }
    }

    public unsafe partial class RetroSubsystemMemoryInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr extension;
            internal uint type;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_subsystem_memory_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSubsystemMemoryInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSubsystemMemoryInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroSubsystemMemoryInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSubsystemMemoryInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroSubsystemMemoryInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSubsystemMemoryInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSubsystemMemoryInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSubsystemMemoryInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSubsystemMemoryInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSubsystemMemoryInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSubsystemMemoryInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSubsystemMemoryInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSubsystemMemoryInfo(global::Libretro.RetroSubsystemMemoryInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSubsystemMemoryInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSubsystemMemoryInfo.__Internal*) __Instance) = *((global::Libretro.RetroSubsystemMemoryInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Extension
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->extension);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->extension = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }
    }

    public unsafe partial class RetroSubsystemRomInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr desc;
            internal __IntPtr valid_extensions;
            internal byte need_fullpath;
            internal byte block_extract;
            internal byte required;
            internal __IntPtr memory;
            internal uint num_memory;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_subsystem_rom_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSubsystemRomInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSubsystemRomInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroSubsystemRomInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSubsystemRomInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroSubsystemRomInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSubsystemRomInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSubsystemRomInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSubsystemRomInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSubsystemRomInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSubsystemRomInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSubsystemRomInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSubsystemRomInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSubsystemRomInfo(global::Libretro.RetroSubsystemRomInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSubsystemRomInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSubsystemRomInfo.__Internal*) __Instance) = *((global::Libretro.RetroSubsystemRomInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->desc);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->desc = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string ValidExtensions
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->valid_extensions);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->valid_extensions = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public bool NeedFullpath
        {
            get
            {
                return ((__Internal*)__Instance)->need_fullpath != 0;
            }

            set
            {
                ((__Internal*)__Instance)->need_fullpath = (byte) (value ? 1 : 0);
            }
        }

        public bool BlockExtract
        {
            get
            {
                return ((__Internal*)__Instance)->block_extract != 0;
            }

            set
            {
                ((__Internal*)__Instance)->block_extract = (byte) (value ? 1 : 0);
            }
        }

        public bool Required
        {
            get
            {
                return ((__Internal*)__Instance)->required != 0;
            }

            set
            {
                ((__Internal*)__Instance)->required = (byte) (value ? 1 : 0);
            }
        }

        public global::Libretro.RetroSubsystemMemoryInfo Memory
        {
            get
            {
                var __result0 = global::Libretro.RetroSubsystemMemoryInfo.__GetOrCreateInstance(((__Internal*)__Instance)->memory, false);
                return __result0;
            }
        }

        public uint NumMemory
        {
            get
            {
                return ((__Internal*)__Instance)->num_memory;
            }

            set
            {
                ((__Internal*)__Instance)->num_memory = value;
            }
        }
    }

    public unsafe partial class RetroSubsystemInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr desc;
            internal __IntPtr ident;
            internal __IntPtr roms;
            internal uint num_roms;
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_subsystem_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSubsystemInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSubsystemInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroSubsystemInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSubsystemInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroSubsystemInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSubsystemInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSubsystemInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSubsystemInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSubsystemInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSubsystemInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSubsystemInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSubsystemInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSubsystemInfo(global::Libretro.RetroSubsystemInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSubsystemInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSubsystemInfo.__Internal*) __Instance) = *((global::Libretro.RetroSubsystemInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->desc);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->desc = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Ident
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ident);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->ident = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public global::Libretro.RetroSubsystemRomInfo Roms
        {
            get
            {
                var __result0 = global::Libretro.RetroSubsystemRomInfo.__GetOrCreateInstance(((__Internal*)__Instance)->roms, false);
                return __result0;
            }
        }

        public uint NumRoms
        {
            get
            {
                return ((__Internal*)__Instance)->num_roms;
            }

            set
            {
                ((__Internal*)__Instance)->num_roms = value;
            }
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    public unsafe partial class RetroGetProcAddressInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr get_proc_address;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_get_proc_address_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGetProcAddressInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGetProcAddressInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroGetProcAddressInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroGetProcAddressInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroGetProcAddressInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroGetProcAddressInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroGetProcAddressInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroGetProcAddressInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroGetProcAddressInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroGetProcAddressInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroGetProcAddressInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGetProcAddressInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroGetProcAddressInterface(global::Libretro.RetroGetProcAddressInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGetProcAddressInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroGetProcAddressInterface.__Internal*) __Instance) = *((global::Libretro.RetroGetProcAddressInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroGetProcAddressT GetProcAddress
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_proc_address;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetProcAddressT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetProcAddressT));
            }

            set
            {
                ((__Internal*)__Instance)->get_proc_address = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroLogCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr log;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_log_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroLogCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroLogCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroLogCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroLogCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroLogCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroLogCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroLogCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroLogCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroLogCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroLogCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroLogCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroLogCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroLogCallback(global::Libretro.RetroLogCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroLogCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroLogCallback.__Internal*) __Instance) = *((global::Libretro.RetroLogCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroLogPrintfT Log
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->log;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroLogPrintfT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroLogPrintfT));
            }

            set
            {
                ((__Internal*)__Instance)->log = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroPerfCounter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr ident;
            internal ulong start;
            internal ulong total;
            internal ulong call_cnt;
            internal byte registered;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_perf_counter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroPerfCounter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroPerfCounter>();

        protected bool __ownsNativeInstance;

        internal static RetroPerfCounter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroPerfCounter(native.ToPointer(), skipVTables);
        }

        internal static RetroPerfCounter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroPerfCounter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroPerfCounter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroPerfCounter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroPerfCounter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroPerfCounter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroPerfCounter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroPerfCounter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroPerfCounter(global::Libretro.RetroPerfCounter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroPerfCounter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroPerfCounter.__Internal*) __Instance) = *((global::Libretro.RetroPerfCounter.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Ident
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ident);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->ident = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public ulong Start
        {
            get
            {
                return ((__Internal*)__Instance)->start;
            }

            set
            {
                ((__Internal*)__Instance)->start = value;
            }
        }

        public ulong Total
        {
            get
            {
                return ((__Internal*)__Instance)->total;
            }

            set
            {
                ((__Internal*)__Instance)->total = value;
            }
        }

        public ulong CallCnt
        {
            get
            {
                return ((__Internal*)__Instance)->call_cnt;
            }

            set
            {
                ((__Internal*)__Instance)->call_cnt = value;
            }
        }

        public bool Registered
        {
            get
            {
                return ((__Internal*)__Instance)->registered != 0;
            }

            set
            {
                ((__Internal*)__Instance)->registered = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class RetroPerfCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr get_time_usec;
            internal __IntPtr get_cpu_features;
            internal __IntPtr get_perf_counter;
            internal __IntPtr perf_register;
            internal __IntPtr perf_start;
            internal __IntPtr perf_stop;
            internal __IntPtr perf_log;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_perf_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroPerfCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroPerfCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroPerfCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroPerfCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroPerfCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroPerfCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroPerfCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroPerfCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroPerfCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroPerfCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroPerfCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroPerfCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroPerfCallback(global::Libretro.RetroPerfCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroPerfCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroPerfCallback.__Internal*) __Instance) = *((global::Libretro.RetroPerfCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroPerfGetTimeUsecT GetTimeUsec
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_time_usec;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroPerfGetTimeUsecT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroPerfGetTimeUsecT));
            }

            set
            {
                ((__Internal*)__Instance)->get_time_usec = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetCpuFeaturesT GetCpuFeatures
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_cpu_features;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetCpuFeaturesT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetCpuFeaturesT));
            }

            set
            {
                ((__Internal*)__Instance)->get_cpu_features = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroPerfGetCounterT GetPerfCounter
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_perf_counter;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroPerfGetCounterT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroPerfGetCounterT));
            }

            set
            {
                ((__Internal*)__Instance)->get_perf_counter = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroPerfRegisterT PerfRegister
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->perf_register;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroPerfRegisterT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroPerfRegisterT));
            }

            set
            {
                ((__Internal*)__Instance)->perf_register = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroPerfStartT PerfStart
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->perf_start;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroPerfStartT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroPerfStartT));
            }

            set
            {
                ((__Internal*)__Instance)->perf_start = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroPerfStopT PerfStop
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->perf_stop;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroPerfStopT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroPerfStopT));
            }

            set
            {
                ((__Internal*)__Instance)->perf_stop = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroPerfLogT PerfLog
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->perf_log;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroPerfLogT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroPerfLogT));
            }

            set
            {
                ((__Internal*)__Instance)->perf_log = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroSensorInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr set_sensor_state;
            internal __IntPtr get_sensor_input;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_sensor_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSensorInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSensorInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroSensorInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSensorInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroSensorInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSensorInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSensorInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSensorInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSensorInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSensorInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSensorInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSensorInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSensorInterface(global::Libretro.RetroSensorInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSensorInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSensorInterface.__Internal*) __Instance) = *((global::Libretro.RetroSensorInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroSetSensorStateT SetSensorState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_sensor_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetSensorStateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetSensorStateT));
            }

            set
            {
                ((__Internal*)__Instance)->set_sensor_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroSensorGetInputT GetSensorInput
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_sensor_input;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSensorGetInputT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSensorGetInputT));
            }

            set
            {
                ((__Internal*)__Instance)->get_sensor_input = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroCameraCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal ulong caps;
            internal uint width;
            internal uint height;
            internal __IntPtr start;
            internal __IntPtr stop;
            internal __IntPtr frame_raw_framebuffer;
            internal __IntPtr frame_opengl_texture;
            internal __IntPtr initialized;
            internal __IntPtr deinitialized;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_camera_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCameraCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCameraCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroCameraCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCameraCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroCameraCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCameraCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCameraCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCameraCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCameraCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCameraCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCameraCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCameraCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCameraCallback(global::Libretro.RetroCameraCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCameraCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCameraCallback.__Internal*) __Instance) = *((global::Libretro.RetroCameraCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ulong Caps
        {
            get
            {
                return ((__Internal*)__Instance)->caps;
            }

            set
            {
                ((__Internal*)__Instance)->caps = value;
            }
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public global::Libretro.RetroCameraStartT Start
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->start;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroCameraStartT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroCameraStartT));
            }

            set
            {
                ((__Internal*)__Instance)->start = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroCameraStopT Stop
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->stop;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroCameraStopT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroCameraStopT));
            }

            set
            {
                ((__Internal*)__Instance)->stop = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroCameraFrameRawFramebufferT FrameRawFramebuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->frame_raw_framebuffer;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroCameraFrameRawFramebufferT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroCameraFrameRawFramebufferT));
            }

            set
            {
                ((__Internal*)__Instance)->frame_raw_framebuffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroCameraFrameOpenglTextureT FrameOpenglTexture
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->frame_opengl_texture;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroCameraFrameOpenglTextureT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroCameraFrameOpenglTextureT));
            }

            set
            {
                ((__Internal*)__Instance)->frame_opengl_texture = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroCameraLifetimeStatusT Initialized
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->initialized;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroCameraLifetimeStatusT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroCameraLifetimeStatusT));
            }

            set
            {
                ((__Internal*)__Instance)->initialized = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroCameraLifetimeStatusT Deinitialized
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->deinitialized;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroCameraLifetimeStatusT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroCameraLifetimeStatusT));
            }

            set
            {
                ((__Internal*)__Instance)->deinitialized = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroLocationCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal __IntPtr start;
            internal __IntPtr stop;
            internal __IntPtr get_position;
            internal __IntPtr set_interval;
            internal __IntPtr initialized;
            internal __IntPtr deinitialized;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_location_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroLocationCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroLocationCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroLocationCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroLocationCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroLocationCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroLocationCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroLocationCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroLocationCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroLocationCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroLocationCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroLocationCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroLocationCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroLocationCallback(global::Libretro.RetroLocationCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroLocationCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroLocationCallback.__Internal*) __Instance) = *((global::Libretro.RetroLocationCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroLocationStartT Start
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->start;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroLocationStartT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroLocationStartT));
            }

            set
            {
                ((__Internal*)__Instance)->start = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroLocationStopT Stop
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->stop;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroLocationStopT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroLocationStopT));
            }

            set
            {
                ((__Internal*)__Instance)->stop = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroLocationGetPositionT GetPosition
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_position;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroLocationGetPositionT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroLocationGetPositionT));
            }

            set
            {
                ((__Internal*)__Instance)->get_position = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroLocationSetIntervalT SetInterval
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_interval;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroLocationSetIntervalT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroLocationSetIntervalT));
            }

            set
            {
                ((__Internal*)__Instance)->set_interval = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroLocationLifetimeStatusT Initialized
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->initialized;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroLocationLifetimeStatusT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroLocationLifetimeStatusT));
            }

            set
            {
                ((__Internal*)__Instance)->initialized = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroLocationLifetimeStatusT Deinitialized
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->deinitialized;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroLocationLifetimeStatusT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroLocationLifetimeStatusT));
            }

            set
            {
                ((__Internal*)__Instance)->deinitialized = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroRumbleInterface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr set_rumble_state;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_rumble_interface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroRumbleInterface> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroRumbleInterface>();

        protected bool __ownsNativeInstance;

        internal static RetroRumbleInterface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroRumbleInterface(native.ToPointer(), skipVTables);
        }

        internal static RetroRumbleInterface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroRumbleInterface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroRumbleInterface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroRumbleInterface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroRumbleInterface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroRumbleInterface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroRumbleInterface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroRumbleInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroRumbleInterface(global::Libretro.RetroRumbleInterface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroRumbleInterface.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroRumbleInterface.__Internal*) __Instance) = *((global::Libretro.RetroRumbleInterface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroSetRumbleStateT SetRumbleState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_rumble_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetRumbleStateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetRumbleStateT));
            }

            set
            {
                ((__Internal*)__Instance)->set_rumble_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroAudioCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr callback;
            internal __IntPtr set_state;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_audio_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroAudioCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroAudioCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroAudioCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroAudioCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroAudioCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroAudioCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroAudioCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroAudioCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroAudioCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroAudioCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroAudioCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroAudioCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroAudioCallback(global::Libretro.RetroAudioCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroAudioCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroAudioCallback.__Internal*) __Instance) = *((global::Libretro.RetroAudioCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroAudioCallbackT Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroAudioCallbackT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroAudioCallbackT));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroAudioSetStateCallbackT SetState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroAudioSetStateCallbackT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroAudioSetStateCallbackT));
            }

            set
            {
                ((__Internal*)__Instance)->set_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroFrameTimeCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr callback;
            internal long reference;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_frame_time_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroFrameTimeCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroFrameTimeCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroFrameTimeCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroFrameTimeCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroFrameTimeCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroFrameTimeCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroFrameTimeCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroFrameTimeCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroFrameTimeCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroFrameTimeCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroFrameTimeCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroFrameTimeCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroFrameTimeCallback(global::Libretro.RetroFrameTimeCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroFrameTimeCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroFrameTimeCallback.__Internal*) __Instance) = *((global::Libretro.RetroFrameTimeCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroFrameTimeCallbackT Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroFrameTimeCallbackT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroFrameTimeCallbackT));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public long Reference
        {
            get
            {
                return ((__Internal*)__Instance)->reference;
            }

            set
            {
                ((__Internal*)__Instance)->reference = value;
            }
        }
    }

    public unsafe partial class RetroAudioBufferStatusCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr callback;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_audio_buffer_status_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroAudioBufferStatusCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroAudioBufferStatusCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroAudioBufferStatusCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroAudioBufferStatusCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroAudioBufferStatusCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroAudioBufferStatusCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroAudioBufferStatusCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroAudioBufferStatusCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroAudioBufferStatusCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroAudioBufferStatusCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroAudioBufferStatusCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroAudioBufferStatusCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroAudioBufferStatusCallback(global::Libretro.RetroAudioBufferStatusCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroAudioBufferStatusCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroAudioBufferStatusCallback.__Internal*) __Instance) = *((global::Libretro.RetroAudioBufferStatusCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroAudioBufferStatusCallbackT Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroAudioBufferStatusCallbackT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroAudioBufferStatusCallbackT));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroHwRenderCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal global::Libretro.RetroHwContextType context_type;
            internal __IntPtr context_reset;
            internal __IntPtr get_current_framebuffer;
            internal __IntPtr get_proc_address;
            internal byte depth;
            internal byte stencil;
            internal byte bottom_left_origin;
            internal uint version_major;
            internal uint version_minor;
            internal byte cache_context;
            internal __IntPtr context_destroy;
            internal byte debug_context;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_hw_render_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroHwRenderCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroHwRenderCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroHwRenderCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroHwRenderCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroHwRenderCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroHwRenderCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroHwRenderCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroHwRenderCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroHwRenderCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroHwRenderCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroHwRenderCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroHwRenderCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroHwRenderCallback(global::Libretro.RetroHwRenderCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroHwRenderCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroHwRenderCallback.__Internal*) __Instance) = *((global::Libretro.RetroHwRenderCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroHwContextType ContextType
        {
            get
            {
                return ((__Internal*)__Instance)->context_type;
            }

            set
            {
                ((__Internal*)__Instance)->context_type = value;
            }
        }

        public global::Libretro.RetroHwContextResetT ContextReset
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->context_reset;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroHwContextResetT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroHwContextResetT));
            }

            set
            {
                ((__Internal*)__Instance)->context_reset = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroHwGetCurrentFramebufferT GetCurrentFramebuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_current_framebuffer;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroHwGetCurrentFramebufferT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroHwGetCurrentFramebufferT));
            }

            set
            {
                ((__Internal*)__Instance)->get_current_framebuffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroHwGetProcAddressT GetProcAddress
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_proc_address;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroHwGetProcAddressT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroHwGetProcAddressT));
            }

            set
            {
                ((__Internal*)__Instance)->get_proc_address = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public bool Depth
        {
            get
            {
                return ((__Internal*)__Instance)->depth != 0;
            }

            set
            {
                ((__Internal*)__Instance)->depth = (byte) (value ? 1 : 0);
            }
        }

        public bool Stencil
        {
            get
            {
                return ((__Internal*)__Instance)->stencil != 0;
            }

            set
            {
                ((__Internal*)__Instance)->stencil = (byte) (value ? 1 : 0);
            }
        }

        public bool BottomLeftOrigin
        {
            get
            {
                return ((__Internal*)__Instance)->bottom_left_origin != 0;
            }

            set
            {
                ((__Internal*)__Instance)->bottom_left_origin = (byte) (value ? 1 : 0);
            }
        }

        public uint VersionMajor
        {
            get
            {
                return ((__Internal*)__Instance)->version_major;
            }

            set
            {
                ((__Internal*)__Instance)->version_major = value;
            }
        }

        public uint VersionMinor
        {
            get
            {
                return ((__Internal*)__Instance)->version_minor;
            }

            set
            {
                ((__Internal*)__Instance)->version_minor = value;
            }
        }

        public bool CacheContext
        {
            get
            {
                return ((__Internal*)__Instance)->cache_context != 0;
            }

            set
            {
                ((__Internal*)__Instance)->cache_context = (byte) (value ? 1 : 0);
            }
        }

        public global::Libretro.RetroHwContextResetT ContextDestroy
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->context_destroy;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroHwContextResetT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroHwContextResetT));
            }

            set
            {
                ((__Internal*)__Instance)->context_destroy = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public bool DebugContext
        {
            get
            {
                return ((__Internal*)__Instance)->debug_context != 0;
            }

            set
            {
                ((__Internal*)__Instance)->debug_context = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class RetroKeyboardCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr callback;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_keyboard_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroKeyboardCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroKeyboardCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroKeyboardCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroKeyboardCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroKeyboardCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroKeyboardCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroKeyboardCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroKeyboardCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroKeyboardCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroKeyboardCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroKeyboardCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroKeyboardCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroKeyboardCallback(global::Libretro.RetroKeyboardCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroKeyboardCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroKeyboardCallback.__Internal*) __Instance) = *((global::Libretro.RetroKeyboardCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroKeyboardEventT Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroKeyboardEventT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroKeyboardEventT));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroDiskControlCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr set_eject_state;
            internal __IntPtr get_eject_state;
            internal __IntPtr get_image_index;
            internal __IntPtr set_image_index;
            internal __IntPtr get_num_images;
            internal __IntPtr replace_image_index;
            internal __IntPtr add_image_index;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_disk_control_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroDiskControlCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroDiskControlCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroDiskControlCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroDiskControlCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroDiskControlCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroDiskControlCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroDiskControlCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroDiskControlCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroDiskControlCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroDiskControlCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroDiskControlCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroDiskControlCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroDiskControlCallback(global::Libretro.RetroDiskControlCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroDiskControlCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroDiskControlCallback.__Internal*) __Instance) = *((global::Libretro.RetroDiskControlCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroSetEjectStateT SetEjectState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_eject_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetEjectStateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetEjectStateT));
            }

            set
            {
                ((__Internal*)__Instance)->set_eject_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetEjectStateT GetEjectState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_eject_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetEjectStateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetEjectStateT));
            }

            set
            {
                ((__Internal*)__Instance)->get_eject_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetImageIndexT GetImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->get_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroSetImageIndexT SetImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->set_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetNumImagesT GetNumImages
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_num_images;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetNumImagesT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetNumImagesT));
            }

            set
            {
                ((__Internal*)__Instance)->get_num_images = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroReplaceImageIndexT ReplaceImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->replace_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroReplaceImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroReplaceImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->replace_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroAddImageIndexT AddImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->add_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroAddImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroAddImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->add_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroDiskControlExtCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal __IntPtr set_eject_state;
            internal __IntPtr get_eject_state;
            internal __IntPtr get_image_index;
            internal __IntPtr set_image_index;
            internal __IntPtr get_num_images;
            internal __IntPtr replace_image_index;
            internal __IntPtr add_image_index;
            internal __IntPtr set_initial_image;
            internal __IntPtr get_image_path;
            internal __IntPtr get_image_label;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_disk_control_ext_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroDiskControlExtCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroDiskControlExtCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroDiskControlExtCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroDiskControlExtCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroDiskControlExtCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroDiskControlExtCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroDiskControlExtCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroDiskControlExtCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroDiskControlExtCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroDiskControlExtCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroDiskControlExtCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroDiskControlExtCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroDiskControlExtCallback(global::Libretro.RetroDiskControlExtCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroDiskControlExtCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroDiskControlExtCallback.__Internal*) __Instance) = *((global::Libretro.RetroDiskControlExtCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroSetEjectStateT SetEjectState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_eject_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetEjectStateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetEjectStateT));
            }

            set
            {
                ((__Internal*)__Instance)->set_eject_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetEjectStateT GetEjectState
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_eject_state;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetEjectStateT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetEjectStateT));
            }

            set
            {
                ((__Internal*)__Instance)->get_eject_state = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetImageIndexT GetImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->get_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroSetImageIndexT SetImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->set_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetNumImagesT GetNumImages
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_num_images;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetNumImagesT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetNumImagesT));
            }

            set
            {
                ((__Internal*)__Instance)->get_num_images = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroReplaceImageIndexT ReplaceImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->replace_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroReplaceImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroReplaceImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->replace_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroAddImageIndexT AddImageIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->add_image_index;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroAddImageIndexT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroAddImageIndexT));
            }

            set
            {
                ((__Internal*)__Instance)->add_image_index = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroSetInitialImageT SetInitialImage
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->set_initial_image;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroSetInitialImageT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroSetInitialImageT));
            }

            set
            {
                ((__Internal*)__Instance)->set_initial_image = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetImagePathT GetImagePath
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_image_path;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetImagePathT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetImagePathT));
            }

            set
            {
                ((__Internal*)__Instance)->get_image_path = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Libretro.RetroGetImageLabelT GetImageLabel
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_image_label;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroGetImageLabelT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroGetImageLabelT));
            }

            set
            {
                ((__Internal*)__Instance)->get_image_label = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr msg;
            internal uint frames;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_message@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMessage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMessage>();

        protected bool __ownsNativeInstance;

        internal static RetroMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroMessage(native.ToPointer(), skipVTables);
        }

        internal static RetroMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroMessage(global::Libretro.RetroMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMessage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroMessage.__Internal*) __Instance) = *((global::Libretro.RetroMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Msg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->msg);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->msg = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public uint Frames
        {
            get
            {
                return ((__Internal*)__Instance)->frames;
            }

            set
            {
                ((__Internal*)__Instance)->frames = value;
            }
        }
    }

    public unsafe partial class RetroMessageExt : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr msg;
            internal uint duration;
            internal uint priority;
            internal global::Libretro.RetroLogLevel level;
            internal global::Libretro.RetroMessageTarget target;
            internal global::Libretro.RetroMessageType type;
            internal sbyte progress;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_message_ext@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMessageExt> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroMessageExt>();

        protected bool __ownsNativeInstance;

        internal static RetroMessageExt __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroMessageExt(native.ToPointer(), skipVTables);
        }

        internal static RetroMessageExt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroMessageExt)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroMessageExt __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroMessageExt(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroMessageExt(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroMessageExt(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroMessageExt()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMessageExt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroMessageExt(global::Libretro.RetroMessageExt _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroMessageExt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroMessageExt.__Internal*) __Instance) = *((global::Libretro.RetroMessageExt.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Msg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->msg);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->msg = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public uint Duration
        {
            get
            {
                return ((__Internal*)__Instance)->duration;
            }

            set
            {
                ((__Internal*)__Instance)->duration = value;
            }
        }

        public uint Priority
        {
            get
            {
                return ((__Internal*)__Instance)->priority;
            }

            set
            {
                ((__Internal*)__Instance)->priority = value;
            }
        }

        public global::Libretro.RetroLogLevel Level
        {
            get
            {
                return ((__Internal*)__Instance)->level;
            }

            set
            {
                ((__Internal*)__Instance)->level = value;
            }
        }

        public global::Libretro.RetroMessageTarget Target
        {
            get
            {
                return ((__Internal*)__Instance)->target;
            }

            set
            {
                ((__Internal*)__Instance)->target = value;
            }
        }

        public global::Libretro.RetroMessageType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public sbyte Progress
        {
            get
            {
                return ((__Internal*)__Instance)->progress;
            }

            set
            {
                ((__Internal*)__Instance)->progress = value;
            }
        }
    }

    public unsafe partial class RetroInputDescriptor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint port;
            internal uint device;
            internal uint index;
            internal uint id;
            internal __IntPtr description;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_input_descriptor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroInputDescriptor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroInputDescriptor>();

        protected bool __ownsNativeInstance;

        internal static RetroInputDescriptor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroInputDescriptor(native.ToPointer(), skipVTables);
        }

        internal static RetroInputDescriptor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroInputDescriptor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroInputDescriptor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroInputDescriptor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroInputDescriptor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroInputDescriptor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroInputDescriptor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroInputDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroInputDescriptor(global::Libretro.RetroInputDescriptor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroInputDescriptor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroInputDescriptor.__Internal*) __Instance) = *((global::Libretro.RetroInputDescriptor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Port
        {
            get
            {
                return ((__Internal*)__Instance)->port;
            }

            set
            {
                ((__Internal*)__Instance)->port = value;
            }
        }

        public uint Device
        {
            get
            {
                return ((__Internal*)__Instance)->device;
            }

            set
            {
                ((__Internal*)__Instance)->device = value;
            }
        }

        public uint Index
        {
            get
            {
                return ((__Internal*)__Instance)->index;
            }

            set
            {
                ((__Internal*)__Instance)->index = value;
            }
        }

        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public string Description
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->description);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->description = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroSystemInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr library_name;
            internal __IntPtr library_version;
            internal __IntPtr valid_extensions;
            internal byte need_fullpath;
            internal byte block_extract;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_system_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroSystemInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSystemInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroSystemInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSystemInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSystemInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSystemInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSystemInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSystemInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSystemInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSystemInfo(global::Libretro.RetroSystemInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSystemInfo.__Internal*) __Instance) = *((global::Libretro.RetroSystemInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string LibraryName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->library_name);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->library_name = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string LibraryVersion
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->library_version);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->library_version = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string ValidExtensions
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->valid_extensions);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->valid_extensions = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public bool NeedFullpath
        {
            get
            {
                return ((__Internal*)__Instance)->need_fullpath != 0;
            }

            set
            {
                ((__Internal*)__Instance)->need_fullpath = (byte) (value ? 1 : 0);
            }
        }

        public bool BlockExtract
        {
            get
            {
                return ((__Internal*)__Instance)->block_extract != 0;
            }

            set
            {
                ((__Internal*)__Instance)->block_extract = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class RetroSystemContentInfoOverride : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr extensions;
            internal byte need_fullpath;
            internal byte persistent_data;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_system_content_info_override@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemContentInfoOverride> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemContentInfoOverride>();

        protected bool __ownsNativeInstance;

        internal static RetroSystemContentInfoOverride __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSystemContentInfoOverride(native.ToPointer(), skipVTables);
        }

        internal static RetroSystemContentInfoOverride __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSystemContentInfoOverride)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSystemContentInfoOverride __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSystemContentInfoOverride(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSystemContentInfoOverride(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSystemContentInfoOverride(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSystemContentInfoOverride()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemContentInfoOverride.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSystemContentInfoOverride(global::Libretro.RetroSystemContentInfoOverride _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemContentInfoOverride.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSystemContentInfoOverride.__Internal*) __Instance) = *((global::Libretro.RetroSystemContentInfoOverride.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Extensions
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->extensions);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->extensions = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public bool NeedFullpath
        {
            get
            {
                return ((__Internal*)__Instance)->need_fullpath != 0;
            }

            set
            {
                ((__Internal*)__Instance)->need_fullpath = (byte) (value ? 1 : 0);
            }
        }

        public bool PersistentData
        {
            get
            {
                return ((__Internal*)__Instance)->persistent_data != 0;
            }

            set
            {
                ((__Internal*)__Instance)->persistent_data = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class RetroGameInfoExt : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal __IntPtr full_path;
            internal __IntPtr archive_path;
            internal __IntPtr archive_file;
            internal __IntPtr dir;
            internal __IntPtr name;
            internal __IntPtr ext;
            internal __IntPtr meta;
            internal __IntPtr data;
            internal ulong size;
            internal byte file_in_archive;
            internal byte persistent_data;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_game_info_ext@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGameInfoExt> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGameInfoExt>();

        protected bool __ownsNativeInstance;

        internal static RetroGameInfoExt __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroGameInfoExt(native.ToPointer(), skipVTables);
        }

        internal static RetroGameInfoExt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroGameInfoExt)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroGameInfoExt __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroGameInfoExt(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroGameInfoExt(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroGameInfoExt(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroGameInfoExt()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGameInfoExt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroGameInfoExt(global::Libretro.RetroGameInfoExt _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGameInfoExt.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroGameInfoExt.__Internal*) __Instance) = *((global::Libretro.RetroGameInfoExt.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string FullPath
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->full_path);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->full_path = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string ArchivePath
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->archive_path);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->archive_path = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string ArchiveFile
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->archive_file);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->archive_file = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Dir
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->dir);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->dir = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->name = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Ext
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ext);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->ext = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Meta
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->meta);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->meta = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->data;
            }
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        public bool FileInArchive
        {
            get
            {
                return ((__Internal*)__Instance)->file_in_archive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->file_in_archive = (byte) (value ? 1 : 0);
            }
        }

        public bool PersistentData
        {
            get
            {
                return ((__Internal*)__Instance)->persistent_data != 0;
            }

            set
            {
                ((__Internal*)__Instance)->persistent_data = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class RetroGameGeometry : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal uint base_width;
            internal uint base_height;
            internal uint max_width;
            internal uint max_height;
            internal float aspect_ratio;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_game_geometry@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGameGeometry> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGameGeometry>();

        protected bool __ownsNativeInstance;

        internal static RetroGameGeometry __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroGameGeometry(native.ToPointer(), skipVTables);
        }

        internal static RetroGameGeometry __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroGameGeometry)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroGameGeometry __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroGameGeometry(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroGameGeometry(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroGameGeometry(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroGameGeometry()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGameGeometry.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroGameGeometry(global::Libretro.RetroGameGeometry _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGameGeometry.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroGameGeometry.__Internal*) __Instance) = *((global::Libretro.RetroGameGeometry.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint BaseWidth
        {
            get
            {
                return ((__Internal*)__Instance)->base_width;
            }

            set
            {
                ((__Internal*)__Instance)->base_width = value;
            }
        }

        public uint BaseHeight
        {
            get
            {
                return ((__Internal*)__Instance)->base_height;
            }

            set
            {
                ((__Internal*)__Instance)->base_height = value;
            }
        }

        public uint MaxWidth
        {
            get
            {
                return ((__Internal*)__Instance)->max_width;
            }

            set
            {
                ((__Internal*)__Instance)->max_width = value;
            }
        }

        public uint MaxHeight
        {
            get
            {
                return ((__Internal*)__Instance)->max_height;
            }

            set
            {
                ((__Internal*)__Instance)->max_height = value;
            }
        }

        public float AspectRatio
        {
            get
            {
                return ((__Internal*)__Instance)->aspect_ratio;
            }

            set
            {
                ((__Internal*)__Instance)->aspect_ratio = value;
            }
        }
    }

    public unsafe partial class RetroSystemTiming : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal double fps;
            internal double sample_rate;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_system_timing@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemTiming> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemTiming>();

        protected bool __ownsNativeInstance;

        internal static RetroSystemTiming __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSystemTiming(native.ToPointer(), skipVTables);
        }

        internal static RetroSystemTiming __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSystemTiming)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSystemTiming __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSystemTiming(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSystemTiming(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSystemTiming(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSystemTiming()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemTiming.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSystemTiming(global::Libretro.RetroSystemTiming _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemTiming.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSystemTiming.__Internal*) __Instance) = *((global::Libretro.RetroSystemTiming.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public double Fps
        {
            get
            {
                return ((__Internal*)__Instance)->fps;
            }

            set
            {
                ((__Internal*)__Instance)->fps = value;
            }
        }

        public double SampleRate
        {
            get
            {
                return ((__Internal*)__Instance)->sample_rate;
            }

            set
            {
                ((__Internal*)__Instance)->sample_rate = value;
            }
        }
    }

    public unsafe partial class RetroSystemAvInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal global::Libretro.RetroGameGeometry.__Internal geometry;
            internal global::Libretro.RetroSystemTiming.__Internal timing;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_system_av_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemAvInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroSystemAvInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroSystemAvInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroSystemAvInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroSystemAvInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroSystemAvInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroSystemAvInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroSystemAvInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroSystemAvInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroSystemAvInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroSystemAvInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemAvInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroSystemAvInfo(global::Libretro.RetroSystemAvInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroSystemAvInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroSystemAvInfo.__Internal*) __Instance) = *((global::Libretro.RetroSystemAvInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroGameGeometry Geometry
        {
            get
            {
                return global::Libretro.RetroGameGeometry.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->geometry));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->geometry = *(global::Libretro.RetroGameGeometry.__Internal*) value.__Instance;
            }
        }

        public global::Libretro.RetroSystemTiming Timing
        {
            get
            {
                return global::Libretro.RetroSystemTiming.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->timing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->timing = *(global::Libretro.RetroSystemTiming.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class RetroVariable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr key;
            internal __IntPtr value;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_variable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVariable> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroVariable>();

        protected bool __ownsNativeInstance;

        internal static RetroVariable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroVariable(native.ToPointer(), skipVTables);
        }

        internal static RetroVariable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroVariable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroVariable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroVariable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroVariable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroVariable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroVariable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroVariable.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroVariable(global::Libretro.RetroVariable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroVariable.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroVariable.__Internal*) __Instance) = *((global::Libretro.RetroVariable.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Key
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->key);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->key = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Value
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->value);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->value = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroCoreOptionDisplay : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr key;
            internal byte visible;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_option_display@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionDisplay> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionDisplay>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionDisplay __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionDisplay(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionDisplay __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionDisplay)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionDisplay __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionDisplay(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionDisplay(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionDisplay(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionDisplay()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionDisplay.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionDisplay(global::Libretro.RetroCoreOptionDisplay _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionDisplay.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionDisplay.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionDisplay.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Key
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->key);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->key = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public bool Visible
        {
            get
            {
                return ((__Internal*)__Instance)->visible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->visible = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class RetroCoreOptionValue : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr value;
            internal __IntPtr label;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_option_value@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionValue> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionValue>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionValue(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionValue)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionValue(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionValue(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionValue(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionValue()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionValue.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionValue(global::Libretro.RetroCoreOptionValue _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionValue.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionValue.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionValue.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Value
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->value);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->value = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Label
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->label);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->label = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroCoreOptionDefinition : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2080)]
        public partial struct __Internal
        {
            internal __IntPtr key;
            internal __IntPtr desc;
            internal __IntPtr info;
            internal fixed byte values[2048];
            internal __IntPtr default_value;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_option_definition@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionDefinition> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionDefinition>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionDefinition __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionDefinition(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionDefinition __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionDefinition)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionDefinition __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionDefinition(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionDefinition(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionDefinition(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionDefinition()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionDefinition.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionDefinition(global::Libretro.RetroCoreOptionDefinition _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionDefinition.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionDefinition.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionDefinition.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Key
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->key);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->key = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->desc);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->desc = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Info
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->info);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->info = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public global::Libretro.RetroCoreOptionValue[] Values
        {
            get
            {
                global::Libretro.RetroCoreOptionValue[] __value = null;
                if (((__Internal*)__Instance)->values != null)
                {
                    __value = new global::Libretro.RetroCoreOptionValue[128];
                    for (int i = 0; i < 128; i++)
                        __value[i] = global::Libretro.RetroCoreOptionValue.__CreateInstance(*((global::Libretro.RetroCoreOptionValue.__Internal*)&(((__Internal*)__Instance)->values[i * sizeof(global::Libretro.RetroCoreOptionValue.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 128)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 128; i++)
                        *(global::Libretro.RetroCoreOptionValue.__Internal*) &((__Internal*)__Instance)->values[i * sizeof(global::Libretro.RetroCoreOptionValue.__Internal)] = *(global::Libretro.RetroCoreOptionValue.__Internal*)value[i].__Instance;
                }
            }
        }

        public string DefaultValue
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->default_value);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->default_value = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroCoreOptionsIntl : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr us;
            internal __IntPtr local;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_options_intl@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsIntl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsIntl>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionsIntl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionsIntl(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionsIntl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionsIntl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionsIntl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionsIntl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionsIntl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionsIntl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionsIntl()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsIntl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionsIntl(global::Libretro.RetroCoreOptionsIntl _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsIntl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionsIntl.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionsIntl.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroCoreOptionDefinition Us
        {
            get
            {
                var __result0 = global::Libretro.RetroCoreOptionDefinition.__GetOrCreateInstance(((__Internal*)__Instance)->us, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->us = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Libretro.RetroCoreOptionDefinition Local
        {
            get
            {
                var __result0 = global::Libretro.RetroCoreOptionDefinition.__GetOrCreateInstance(((__Internal*)__Instance)->local, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->local = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class RetroCoreOptionV2Category : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr key;
            internal __IntPtr desc;
            internal __IntPtr info;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_option_v2_category@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionV2Category> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionV2Category>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionV2Category __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionV2Category(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionV2Category __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionV2Category)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionV2Category __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionV2Category(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionV2Category(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionV2Category(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionV2Category()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionV2Category.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionV2Category(global::Libretro.RetroCoreOptionV2Category _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionV2Category.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionV2Category.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionV2Category.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Key
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->key);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->key = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->desc);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->desc = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Info
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->info);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->info = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroCoreOptionV2Definition : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 2104)]
        public partial struct __Internal
        {
            internal __IntPtr key;
            internal __IntPtr desc;
            internal __IntPtr desc_categorized;
            internal __IntPtr info;
            internal __IntPtr info_categorized;
            internal __IntPtr category_key;
            internal fixed byte values[2048];
            internal __IntPtr default_value;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_option_v2_definition@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionV2Definition> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionV2Definition>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionV2Definition __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionV2Definition(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionV2Definition __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionV2Definition)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionV2Definition __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionV2Definition(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionV2Definition(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionV2Definition(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionV2Definition()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionV2Definition.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionV2Definition(global::Libretro.RetroCoreOptionV2Definition _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionV2Definition.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionV2Definition.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionV2Definition.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Key
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->key);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->key = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->desc);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->desc = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string DescCategorized
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->desc_categorized);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->desc_categorized = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string Info
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->info);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->info = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string InfoCategorized
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->info_categorized);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->info_categorized = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string CategoryKey
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->category_key);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->category_key = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public global::Libretro.RetroCoreOptionValue[] Values
        {
            get
            {
                global::Libretro.RetroCoreOptionValue[] __value = null;
                if (((__Internal*)__Instance)->values != null)
                {
                    __value = new global::Libretro.RetroCoreOptionValue[128];
                    for (int i = 0; i < 128; i++)
                        __value[i] = global::Libretro.RetroCoreOptionValue.__CreateInstance(*((global::Libretro.RetroCoreOptionValue.__Internal*)&(((__Internal*)__Instance)->values[i * sizeof(global::Libretro.RetroCoreOptionValue.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 128)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 128; i++)
                        *(global::Libretro.RetroCoreOptionValue.__Internal*) &((__Internal*)__Instance)->values[i * sizeof(global::Libretro.RetroCoreOptionValue.__Internal)] = *(global::Libretro.RetroCoreOptionValue.__Internal*)value[i].__Instance;
                }
            }
        }

        public string DefaultValue
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->default_value);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->default_value = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroCoreOptionsV2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr categories;
            internal __IntPtr definitions;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_options_v2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsV2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsV2>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionsV2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionsV2(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionsV2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionsV2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionsV2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionsV2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionsV2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionsV2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionsV2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsV2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionsV2(global::Libretro.RetroCoreOptionsV2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsV2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionsV2.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionsV2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroCoreOptionV2Category Categories
        {
            get
            {
                var __result0 = global::Libretro.RetroCoreOptionV2Category.__GetOrCreateInstance(((__Internal*)__Instance)->categories, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->categories = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Libretro.RetroCoreOptionV2Definition Definitions
        {
            get
            {
                var __result0 = global::Libretro.RetroCoreOptionV2Definition.__GetOrCreateInstance(((__Internal*)__Instance)->definitions, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->definitions = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class RetroCoreOptionsV2Intl : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr us;
            internal __IntPtr local;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_options_v2_intl@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsV2Intl> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsV2Intl>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionsV2Intl __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionsV2Intl(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionsV2Intl __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionsV2Intl)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionsV2Intl __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionsV2Intl(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionsV2Intl(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionsV2Intl(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionsV2Intl()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsV2Intl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionsV2Intl(global::Libretro.RetroCoreOptionsV2Intl _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsV2Intl.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionsV2Intl.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionsV2Intl.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroCoreOptionsV2 Us
        {
            get
            {
                var __result0 = global::Libretro.RetroCoreOptionsV2.__GetOrCreateInstance(((__Internal*)__Instance)->us, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->us = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Libretro.RetroCoreOptionsV2 Local
        {
            get
            {
                var __result0 = global::Libretro.RetroCoreOptionsV2.__GetOrCreateInstance(((__Internal*)__Instance)->local, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->local = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class RetroCoreOptionsUpdateDisplayCallback : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal __IntPtr callback;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_core_options_update_display_callback@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsUpdateDisplayCallback> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroCoreOptionsUpdateDisplayCallback>();

        protected bool __ownsNativeInstance;

        internal static RetroCoreOptionsUpdateDisplayCallback __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroCoreOptionsUpdateDisplayCallback(native.ToPointer(), skipVTables);
        }

        internal static RetroCoreOptionsUpdateDisplayCallback __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroCoreOptionsUpdateDisplayCallback)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroCoreOptionsUpdateDisplayCallback __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroCoreOptionsUpdateDisplayCallback(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroCoreOptionsUpdateDisplayCallback(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroCoreOptionsUpdateDisplayCallback(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroCoreOptionsUpdateDisplayCallback()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsUpdateDisplayCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroCoreOptionsUpdateDisplayCallback(global::Libretro.RetroCoreOptionsUpdateDisplayCallback _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroCoreOptionsUpdateDisplayCallback.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroCoreOptionsUpdateDisplayCallback.__Internal*) __Instance) = *((global::Libretro.RetroCoreOptionsUpdateDisplayCallback.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Libretro.RetroCoreOptionsUpdateDisplayCallbackT Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::Libretro.RetroCoreOptionsUpdateDisplayCallbackT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Libretro.RetroCoreOptionsUpdateDisplayCallbackT));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RetroGameInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr path;
            internal __IntPtr data;
            internal ulong size;
            internal __IntPtr meta;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_game_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGameInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroGameInfo>();

        protected bool __ownsNativeInstance;

        internal static RetroGameInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroGameInfo(native.ToPointer(), skipVTables);
        }

        internal static RetroGameInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroGameInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroGameInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroGameInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroGameInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroGameInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroGameInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGameInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroGameInfo(global::Libretro.RetroGameInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroGameInfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroGameInfo.__Internal*) __Instance) = *((global::Libretro.RetroGameInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Path
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->path);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->path = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->data;
            }
        }

        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        public string Meta
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->meta);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->meta = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }
    }

    public unsafe partial class RetroFramebuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr data;
            internal uint width;
            internal uint height;
            internal ulong pitch;
            internal global::Libretro.RetroPixelFormat format;
            internal uint access_flags;
            internal uint memory_flags;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_framebuffer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroFramebuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroFramebuffer>();

        protected bool __ownsNativeInstance;

        internal static RetroFramebuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroFramebuffer(native.ToPointer(), skipVTables);
        }

        internal static RetroFramebuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroFramebuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroFramebuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroFramebuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroFramebuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroFramebuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroFramebuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroFramebuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroFramebuffer(global::Libretro.RetroFramebuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroFramebuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroFramebuffer.__Internal*) __Instance) = *((global::Libretro.RetroFramebuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }

        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public ulong Pitch
        {
            get
            {
                return ((__Internal*)__Instance)->pitch;
            }

            set
            {
                ((__Internal*)__Instance)->pitch = value;
            }
        }

        public global::Libretro.RetroPixelFormat Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        public uint AccessFlags
        {
            get
            {
                return ((__Internal*)__Instance)->access_flags;
            }

            set
            {
                ((__Internal*)__Instance)->access_flags = value;
            }
        }

        public uint MemoryFlags
        {
            get
            {
                return ((__Internal*)__Instance)->memory_flags;
            }

            set
            {
                ((__Internal*)__Instance)->memory_flags = value;
            }
        }
    }

    public unsafe partial class RetroFastforwardingOverride : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float ratio;
            internal byte fastforward;
            internal byte notification;
            internal byte inhibit_toggle;

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "??0retro_fastforwarding_override@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroFastforwardingOverride> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Libretro.RetroFastforwardingOverride>();

        protected bool __ownsNativeInstance;

        internal static RetroFastforwardingOverride __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RetroFastforwardingOverride(native.ToPointer(), skipVTables);
        }

        internal static RetroFastforwardingOverride __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RetroFastforwardingOverride)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RetroFastforwardingOverride __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RetroFastforwardingOverride(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RetroFastforwardingOverride(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RetroFastforwardingOverride(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RetroFastforwardingOverride()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroFastforwardingOverride.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RetroFastforwardingOverride(global::Libretro.RetroFastforwardingOverride _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Libretro.RetroFastforwardingOverride.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Libretro.RetroFastforwardingOverride.__Internal*) __Instance) = *((global::Libretro.RetroFastforwardingOverride.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Ratio
        {
            get
            {
                return ((__Internal*)__Instance)->ratio;
            }

            set
            {
                ((__Internal*)__Instance)->ratio = value;
            }
        }

        public bool Fastforward
        {
            get
            {
                return ((__Internal*)__Instance)->fastforward != 0;
            }

            set
            {
                ((__Internal*)__Instance)->fastforward = (byte) (value ? 1 : 0);
            }
        }

        public bool Notification
        {
            get
            {
                return ((__Internal*)__Instance)->notification != 0;
            }

            set
            {
                ((__Internal*)__Instance)->notification = (byte) (value ? 1 : 0);
            }
        }

        public bool InhibitToggle
        {
            get
            {
                return ((__Internal*)__Instance)->inhibit_toggle != 0;
            }

            set
            {
                ((__Internal*)__Instance)->inhibit_toggle = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class libretro
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_set_environment", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroSetEnvironment(__IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_set_video_refresh", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroSetVideoRefresh(__IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_set_audio_sample", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroSetAudioSample(__IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_set_audio_sample_batch", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroSetAudioSampleBatch(__IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_set_input_poll", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroSetInputPoll(__IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_set_input_state", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroSetInputState(__IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroInit();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_deinit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroDeinit();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_api_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint RetroApiVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_get_system_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroGetSystemInfo(__IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_get_system_av_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroGetSystemAvInfo(__IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_set_controller_port_device", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroSetControllerPortDevice(uint port, uint device);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroReset();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_run", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroRun();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_serialize_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong RetroSerializeSize();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_serialize", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RetroSerialize(__IntPtr data, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_unserialize", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RetroUnserialize(__IntPtr data, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_cheat_reset", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroCheatReset();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_cheat_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroCheatSet(uint index, bool enabled, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string code);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_load_game", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RetroLoadGame(__IntPtr game);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_load_game_special", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool RetroLoadGameSpecial(uint game_type, __IntPtr info, ulong num_info);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_unload_game", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RetroUnloadGame();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_get_region", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint RetroGetRegion();

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_get_memory_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr RetroGetMemoryData(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("Libretro", EntryPoint = "retro_get_memory_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong RetroGetMemorySize(uint id);
        }

        public static void RetroSetEnvironment(global::Libretro.RetroEnvironmentT _0)
        {
            var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
            __Internal.RetroSetEnvironment(__arg0);
        }

        public static void RetroSetVideoRefresh(global::Libretro.RetroVideoRefreshT _0)
        {
            var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
            __Internal.RetroSetVideoRefresh(__arg0);
        }

        public static void RetroSetAudioSample(global::Libretro.RetroAudioSampleT _0)
        {
            var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
            __Internal.RetroSetAudioSample(__arg0);
        }

        public static void RetroSetAudioSampleBatch(global::Libretro.RetroAudioSampleBatchT _0)
        {
            var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
            __Internal.RetroSetAudioSampleBatch(__arg0);
        }

        public static void RetroSetInputPoll(global::Libretro.RetroInputPollT _0)
        {
            var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
            __Internal.RetroSetInputPoll(__arg0);
        }

        public static void RetroSetInputState(global::Libretro.RetroInputStateT _0)
        {
            var __arg0 = _0 == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_0);
            __Internal.RetroSetInputState(__arg0);
        }

        public static void RetroInit()
        {
            __Internal.RetroInit();
        }

        public static void RetroDeinit()
        {
            __Internal.RetroDeinit();
        }

        public static uint RetroApiVersion()
        {
            var __ret = __Internal.RetroApiVersion();
            return __ret;
        }

        public static void RetroGetSystemInfo(global::Libretro.RetroSystemInfo info)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            __Internal.RetroGetSystemInfo(__arg0);
        }

        public static void RetroGetSystemAvInfo(global::Libretro.RetroSystemAvInfo info)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            __Internal.RetroGetSystemAvInfo(__arg0);
        }

        public static void RetroSetControllerPortDevice(uint port, uint device)
        {
            __Internal.RetroSetControllerPortDevice(port, device);
        }

        public static void RetroReset()
        {
            __Internal.RetroReset();
        }

        public static void RetroRun()
        {
            __Internal.RetroRun();
        }

        public static ulong RetroSerializeSize()
        {
            var __ret = __Internal.RetroSerializeSize();
            return __ret;
        }

        public static bool RetroSerialize(__IntPtr data, ulong size)
        {
            var __ret = __Internal.RetroSerialize(data, size);
            return __ret;
        }

        public static bool RetroUnserialize(__IntPtr data, ulong size)
        {
            var __ret = __Internal.RetroUnserialize(data, size);
            return __ret;
        }

        public static void RetroCheatReset()
        {
            __Internal.RetroCheatReset();
        }

        public static void RetroCheatSet(uint index, bool enabled, string code)
        {
            __Internal.RetroCheatSet(index, enabled, code);
        }

        public static bool RetroLoadGame(global::Libretro.RetroGameInfo game)
        {
            var __arg0 = game is null ? __IntPtr.Zero : game.__Instance;
            var __ret = __Internal.RetroLoadGame(__arg0);
            return __ret;
        }

        public static bool RetroLoadGameSpecial(uint game_type, global::Libretro.RetroGameInfo info, ulong num_info)
        {
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.RetroLoadGameSpecial(game_type, __arg1, num_info);
            return __ret;
        }

        public static void RetroUnloadGame()
        {
            __Internal.RetroUnloadGame();
        }

        public static uint RetroGetRegion()
        {
            var __ret = __Internal.RetroGetRegion();
            return __ret;
        }

        public static __IntPtr RetroGetMemoryData(uint id)
        {
            var __ret = __Internal.RetroGetMemoryData(id);
            return __ret;
        }

        public static ulong RetroGetMemorySize(uint id)
        {
            var __ret = __Internal.RetroGetMemorySize(id);
            return __ret;
        }
    }
}
